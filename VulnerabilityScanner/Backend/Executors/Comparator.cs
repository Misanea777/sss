using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms.VisualStyles;

namespace VulnerabilityScanner.Backend.Executors
{
    class Comparator
    {
        struct numberRange
        {
            uint lNumber;
            uint hNumber;
        }

        public static bool compare(string dataValue, string dataType, string valueToCompare)
        {
            uint parsedValue;
            uint.TryParse(valueToCompare, out parsedValue);

            if (dataType.Equals("POLICY_DWORD")
                || dataType.Equals("TIME_DAY")
                || dataType.Equals("TIME_MINUTE")
                || dataType.Equals("TIME_HOUR"))
            {
                if (dataValue.StartsWith("\"") && dataValue.EndsWith("\"")) dataValue = dataValue.Substring(1, dataValue.Length - 2);

                if (uint.TryParse(dataValue, out _))
                {
                    return dataValue.Equals(valueToCompare);
                }
                if(dataValue.StartsWith("[") && dataValue.EndsWith("]"))
                {
                    bool firstCheck = false;
                    bool secondCheck = false;
                    uint tmp1;

                    dataValue = dataValue.Substring(1, dataValue.Length - 2);
                    string[] spliter = { ".." };
                    var pices = dataValue.Split(spliter, StringSplitOptions.None);
                    if (uint.TryParse(pices[0], out tmp1))
                    {
                        firstCheck = tmp1 <= parsedValue;
                    }
                    else if(parsedValue != 0) firstCheck = true;
                    else firstCheck = false;


                    if (uint.TryParse(pices[1], out tmp1))
                    {
  
                        secondCheck = tmp1 >= parsedValue;
                    }
                    else secondCheck = true;

                    if (firstCheck && secondCheck) return true;
                    else return false;
                }
            }

            if(dataType.Equals("POLICY_SET"))
            {
                if (dataValue.StartsWith("\"") && dataValue.EndsWith("\"")) dataValue = dataValue.Substring(1, dataValue.Length - 2);
                int enabled = -1;
                if (dataValue.Equals("Enabled")) enabled = 1;
                if (dataValue.Equals("Disabled")) enabled = 0;
                return enabled == parsedValue;  
            }

            if(dataType.Equals("POLICY_TEXT")
                || dataType.Equals("POLICY_MULTI_TEXT"))
            {
                string genPattern = dataValue.Replace("\"", String.Empty).Replace("\'", String.Empty).Trim();
                string[] patterns = genPattern.Split(new string[] { "&&" }, StringSplitOptions.None);
                List<Regex> regices = new List<Regex>();
                foreach(string s in patterns)
                {
                    regices.Add(new Regex(ToLiteral(s)));
                }

                string[] separator = { "\\0" };
                string[] pices = valueToCompare.Split(separator, StringSplitOptions.None);
                foreach(string s in pices)
                {
                    
                    foreach(Regex r in regices)
                    {
                        if (r.IsMatch(s)) return true;
                    }
                }
                return false;
            }

            if(dataType.Equals("AUDIT_SET"))
            {
                string[] separator = { " || " };
                string[] pices = dataValue.Split(separator, StringSplitOptions.RemoveEmptyEntries);
                for(int i=0; i<pices.Length; i++)
                {
                    pices[i] = pices[i].Substring(1, pices[i].Length - 2);
                }

                string[] spliter = { "|" };
                valueToCompare = Regex.Replace(valueToCompare, @"\s\s+", "|").Split(spliter, StringSplitOptions.None)[1].Replace(" and ", ", ");

                foreach (string s in pices)
                {
                    if (s.Equals(valueToCompare)) return true;
                }

                return false;
            }

            if(dataType.Equals("USER_RIGHT"))
            {
                valueToCompare = valueToCompare.Replace(",*", " && ").Replace("*", "");
                
                dataValue = Regex.Replace(dataValue, "\".*?\"", m => Converter.getSidFromName(m.Value.Substring(1, m.Value.Length-2)));

                string[] separator = { " && " };
                string[] valuesToCompare = valueToCompare.Split(separator, StringSplitOptions.None);

                string[] spliter = { " || " };
                string[] options = dataValue.Split(spliter, StringSplitOptions.None);
                for (int i = 0; i < options.Length; i++)
                {
                    options[i] = options[i].Replace("(", "").Replace(")", "");
                    if (compareStringArrays(options[i].Split(separator, StringSplitOptions.None), valuesToCompare))
                    {
                        return true;
                    }
                }

                return false;
            }

            Console.WriteLine("Should not be here");
            return false;
        }

        public static string ToLiteral(string input)
        {
            input = input.Replace(@"\\", @"\").Replace(@"\", @"\\").Trim();
            return input;
        }

        public static bool compareStringArrays(string[] a1, string[] a2)
        {
            if (a1.Length != a2.Length) return false;
            Array.Sort(a1);
            Array.Sort(a2);
            for(int i=0; i<a1.Length; i++)
            {
                if (!a2[i].Contains(a1[i])) return false;
            }
            return true;
        }


    }
}
